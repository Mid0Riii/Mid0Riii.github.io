{"pages":[],"posts":[{"title":"C语言教程目录","text":"这些是19年暑假里技术交流协会写的教程目录。配套的练习题因为OJ管理的原因失效了，但是教程本体都可以在协会的BBS阅读。 我只写了其中的函数部分，因此博客只搬运了函数那部分。 为帮助大家更好地入门C语言，今年我们采用了全新的线上教学方式， 即做题+讨论模式， 为此我们开放了Online Judge和论坛， 您可以在OJ上仔细阅读我们编写的教程， 完成教程后的练习题， 参与我们组织的周赛， 并在论坛加以讨论。如果您有任何问题， 都欢迎您在教程对应的讨论帖下发表您的疑问， 您的疑问会由教程及习题的编者亲自回答。如果有任何其他问题， 您都可以在本帖下进行回复。由于时间及人力关系， 在教程和习题的编写过程中难免会出现一些问题， 希望能得到各位大佬的指正。希望大家学到知识， 玩得开心。 讨论区 你的第一个hello world 数据类型 输入输出 表达式、运算符和语句 条件语句 循环语句 程序调试tips 函数 递归 数组 指针 字符串 动态分配内存 结构体 位运算 文件操作","link":"/C%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%E7%9B%AE%E5%BD%95.html"},{"title":"图的邻接矩阵存储、最小生成树普里姆算法以及最短路径的Dijkstra算法","text":"图的邻接矩阵存储及其实现邻接矩阵是常用的存储图的信息的方法，如下图所示 其中，边数组描述了图上的各个顶点之间的关系。此矩阵通常具有以下性质 对角线上的元素全部为0，表示每个顶点到自身的权值/距离为0 若图为无向图，则邻接矩阵为对称矩阵 其余元素表示各顶点之间的路径权值，若为无限或其他规定值，则顶点与顶点之间不联通 由此可以看出，我们若想在程序中采用邻接矩阵的方式对图进行存储，需要建立一个用来存储顶点信息的一维数组和一个用来存储边信息的二位数组。 以下为图的邻接矩阵存储的C语言类型定义实现 1typedef struct {2 vertextype vex[M]; //顶点信息3 edgetype edges[M][M];//邻接矩阵4 int n; //顶点数5 int e; //边数6}Mgraph; 方便起见，我们从文件中对图的数据进行读入，文件格式如下 16 102ABCDEF30 1 1040 2 1250 4 1561 2 772 4 1281 3 591 5 6102 5 8113 5 6124 5 10 其中，第一行的两个数字分别表示该图中顶点的个数以及边的个数。第二行的字母表示每个顶点的名称。 其余各行则以“起始点 结束点 权值”的格式描述了图的结构。如在以上文件中，“0 1 10”表示从第0个点到第1个点有一条权值10的边。 图的邻接矩阵存储算法如下 1#include &lt;stdio.h&gt;2#define FINITY 50003#define M 20 //最大顶点数4typedef char vertextype; //顶点值类型5typedef int edgetype; //权值类型6void create(Mgraph *g,char *s,int c){ //C=0表示建立无向图，否则建立有向图7 int i,j,k,w;8 FILE *rf;9 rf = fopen(s,\"r\");10 if(rf){11 fscanf(rf,\"%d%d\",&amp;g-&gt;n,&amp;g-&gt;e); //输入顶点数与边数12 for(i = 0;i&lt;g-&gt;n;i++){13 fscanf(rf,\"%1s\",&amp;g-&gt;vex[i]); //输入顶点名14 }15 for(i = 0;i&lt;g-&gt;n;i++){ //初始化邻接矩阵16 for(j = 0;j&lt;g-&gt;n;j++){17 if(i==j){18 g-&gt;edges[i][j] =0; //邻接矩阵对角线置019 }else{20 g-&gt;edges[i][j] = FINITY;//其余置无限21 }22 }23 }24 for(k = 0;k&lt;g-&gt;e;k++){25 fscanf(rf,\"%d%d%d\",&amp;i,&amp;j,&amp;w); //读入文件中的顶点i，顶点j，权值w26 g-&gt;edges[i][j] = w; //邻接矩阵i行j列信息置权值27 if(c==0){28 g-&gt;edges[j][i]=w; //若为无向图，则j行i列信息也置权值29 }30 }31 fclose(rf);32 }else{33 g-&gt;n=0;34 }35} 以上，我们实现了图的邻接矩阵存储 图的最小生成树的普里姆算法 一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。 最小生成树可以用kruskal（克鲁斯卡尔）算法或prim（普里姆）算法求出。 简单来说，就是在把图的各个顶点连接起来的同时，保证路径的总权值最小。 下面介绍图的普里姆算法 此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。 图的所有顶点集合为V；初始令集合u={s},v=V−u; 在两个集合u,v能够组成的边中，选择一条权重最小的边(u0,v0)，加入到最小生成树中，并把v0并入到集合u中。 重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。 由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组tree[],用来维护集合v中每个顶点与集合u中最小代价边信息，： 以下为其算法实现 1//边集2typedef struct {3 int beg; //起始顶点4 int en; //结束顶点5 int length; //权值6}edge;78//普里姆算法9void prim(Mgraph g,edge tree[M-1]){10 edge x;11 int d,min,j,k,s,v;12 for(v = 1;v&lt;=g.n-1;v++){ //初始化边集tree中的每一个元素i为起点为0，终点为v的边13 tree[v-1].beg = 0;14 tree[v-1].en = v;15 tree[v-1].length = g.edges[0][v];16 }17 for(k = 0;k&lt;=g.n-3;k++){18 min = tree[k].length; //初始化程序当前认为的最小边min19 s = k;20 for(j = k+1;j&lt;=g.n-2;j++){21 if(tree[j].length&lt;min){ //如果当前边的权值小于目前最小值22 min = tree[j].length; //令最小值等于当前边权值23 s = j; //令s等于最短边在tree中的索引24 }25 }26 v = tree[s].en; //取最短边的结束点为v27 x = tree[s]; //交换tree中的第s条边和第k条边，使当前最小边加入tree28 tree[s] = tree[k]; 29 tree[k] = x; //交换完毕后，此时tree数组中的前k个元素为已经求得的最短路径30 for(j=k+1;j&lt;=g.n-2;j++){ //由于v更换，更新两栖边信息，注意此处由k+1开始遍历tree31 d = g.edges[v][tree[j].en]; 32 if(d&lt;tree[j].length){33 tree[j].beg = v; //设定tree[j]的起始点为v34 tree[j].length = d; //更新当前结束点v到tree[j]元素的距离35 }36 }37 }38 //输出最小生成树39 printf(\"\\n the minimun cost spanning tree is :\\n\");40 for(j = 0;j&lt;=g.n-2;j++){41 printf(\"\\n%c---%c %d\\n\",g.vex[tree[j].beg],g.vex[tree[j].en],tree[j].length);42 }43 printf(\"\\n the root of it is %c\\n\",g.vex[0]);44} 运行结果如下 1# 测试数据 G1.txt26 103ABCDEF40 1 1050 2 1260 4 1571 2 782 4 1291 3 5101 5 6112 5 8123 5 6134 5 10 1#终端输出2the minimun cost spanning tree is :3A---B 104B---D 55B---F 66B---C 77F---E 10 由此，我们利用了普里姆算法求得了图的最小生成树。 利用Dijkstra算法求图的单源最短路径求解图的单源最短路径问题很好理解，就是对于给定的图上的顶点v0，找出一条路径使其能够到达其他顶点且路径的权重和最小。 我们可以利用Dijkstra算法求解图的单源最短路径； 基本思想：每次找到离源点（如1号结点）最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。 以下为其算法实现 1typedef enum {FALSE,TRUE} boolean; //令FALSE为0，TRUE为12typedef int dist[M]; //用于保存边的信息3typedef int path[M]; //用于保存路径信息45void dijkstra(Mgraph g,int v0,path p,dist d){6 boolean final[M]; //初始化final数组用于标记当前元素是否已求出最短路径7 int i,j,k,v,min,x;8 for(v = 0;v&lt;g.n;v++){ //初始化第一组集合9 final[v] = FALSE; //当前元素未求出最短路径10 d[v] = g.edges[v0][v]; //令d[v]等于v0至v的距离11 if(d[v]&lt;FINITY &amp;&amp; d[v]!=0){ //若v0至v的距离不为无限或012 p[v] = v0; //则令p的前驱为v013 }else{14 p[v] = -1; //否则，p无前驱15 }16 }17 final[v0] = TRUE; //初始化源点18 d[v0] = 0; 19 for(i = 1;i&lt;g.n;i++){20 min = FINITY; //初始化最小值21 for(k = 0;k&lt;g.n;k++){ //遍历图找寻最短路径，g.n表示图的顶点数22 if(!final[k] &amp;&amp; d[k]&lt;min){ //若k未被访问过且k的权值小于当前最小值23 v = k; //标记索引为k的顶点为v24 min = d[k]; //当前最小值置k的权值25 }26 }27 printf(\"\\n%c---%d\\n\",g.vex[v],min);28 if(min == FINITY){ //非连通图不存在生成树，返回29 return;30 }31 final[v] =TRUE; //v与源点之间存在最短路径32 for(k = 0;k&lt;g.n;k++){ //源点改变为v，更新路径信息33 if(!final[k] &amp;&amp; (min+g.edges[v][k]&lt;d[k])){ //若k未访问过且当前路径长度小于v0至k的权值34 d[k] = min+g.edges[v][k]; //路径长度相加35 p[k] = v;36 }37 }38 }39}40//输出最短路径41void print_gpd(Mgraph g,path p,dist d){42 int st[M],i,pre,top = -1;43 for(i = 0;i&lt;g.n;i++){44 printf(\"\\n Distancd :%7d path:\",d[i]);45 st[++top] = i;46 pre = p[i];47 while(pre !=-1){48 st[++top] = pre;49 pre = p[pre];50 }51 while(top&gt;0){52 printf(\"%2d\",st[top--]);53 }54 }55}","link":"/prim-dijkstra.html"},{"title":"C语言教程-函数部分","text":"这位可怜的工程师朋友搜肠刮肚穷尽毕生所学开始想你这个程序是干嘛的，然后地球就毁灭了。 引入在开始函数部分的学习之前，我们先看一下以下问题 题目1：编写一个程序，判断输入的一个整数是否为一个偶数 1//例1.12#include&lt;stdio.h&gt;3int main(){4 int a;5 scanf(\"%d\", &amp;a);6 if(a % 2 != 0){7 printf(\"%d is not an even number\",a);8 }else{9 printf(\"%d is an even number\",a);10 }11 return 0;12} 你觉得这个太简单了，很快便编写出了上述的程序。这道题当然难不倒我们，我们来看第二道题 题目2：编写一个程序，求输入的两个整数的最大公因数 1//例1.22#include&lt;stdio.h&gt;3int main()4{5 int x,y,z,t,ans;6 scanf(\"%d %d\",&amp;x,&amp;y);7 if(x &lt; y){8 t = y;9 y = x;10 x = t;11 }12 do{13 z = x % y;14 x = y;15 y = z;16 }while(z != 0);17 ans = x;18 printf(\"%d is the GCD\",ans); 19 return 0;20 } 这道题可能稍微麻烦一点，不过你想起了以前学习过的最大公因数的定义以及辗转相除法求最大公因数的方法，很快便解出了这道题。这个程序就满足我们这道题的需求而言，已经足够了；不过，若是用工程的思想来看的话，它是存在着某种缺憾的，而这个缺憾将在下一个题目中暴露出来。 题目3：编写一个程序，判断输入的一个整数是否为一个偶数，再求输入的两个整数的最大公因数 1//例1.32#include&lt;stdio.h&gt;3int main(){4 int a;5 int x,y,z,t,ans;6 scanf(\"%d\", &amp;a);7 if(a % 2 != 0){8 printf(\"%d is not an even number\",a);9 }else{10 printf(\"%d is an even number\",a);11 }12 scanf(\"%d %d\",&amp;x,&amp;y);13 if(x &lt; y){14 t = y;15 y = x;16 x = t;17 }18 do{19 z = x % y;20 x = y;21 y = z;22 }while(z != 0);23 ans = x;24 printf(\"%d is the GCD\",ans);25 return 0;26} 这题无聊死了，把你的前两个题目复制粘贴，结束了。 这道题确实是这样结束了，但是我们面临的问题才刚刚开始。假设你写完了这个程序，然后就遗忘了，若干年后，外星人入侵地球，他们随便抓了一个工程师，并拿出了你的程序 “三秒内说出这个程序是用来干啥的，不然我们就毁灭地球” 这位可怜的工程师朋友搜肠刮肚穷尽毕生所学开始想你这个程序是干嘛的，然后地球就毁灭了。 毕竟人类的阅读能力是有限的，而阅读代码又是一种图穷匕见的工作，在阅读陌生代码时，往往只有阅读到最后几行你才能有把握说出这个程序是用来干什么的，在这位工程师朋友能够阅读到揭示这段代码的作用的代码段之前，外星人早就不耐烦了，于是地球就毁灭了。 我们来思索，地球为什么会毁灭？原因在于，你的代码可读性不佳。可读性，也就是要让大家一眼就能理解明白程序的思路与用意，可读性不佳，就是说你的代码读起来有点费劲，没法让人一下子搞明白这些变量是用来干嘛的，这段程序又是用来干嘛的。 我们把可读性的问题暂且放在一边，毕竟外星人入侵是若干年后的事，眼前我们还有题目要做。 题目4：程序会输入7个数，完成以下操作 判断第一个数是否为偶数 判断第二个数是否为偶数 求第三个数和第四个数的最大公因数 判断第五个数是否为偶数 求第六个数和第七个数的最大公因数。 1//例1.42#include&lt;stdio.h&gt;3int main(){4 int a;5 int x,y,z,t,ans;6 scanf(\"%d\", &amp;a);7 if(a % 2 != 0){8 printf(\"%d is not an even number\\n\",a);9 }else{10 printf(\"%d is an even number\\n\",a);11 }12 scanf(\"%d\", &amp;a);13 if(a % 2 != 0){14 printf(\"%d is not an even number\\n\",a);15 }else{16 printf(\"%d is an even number\\n\",a);17 }18 scanf(\"%d %d\",&amp;x,&amp;y);19 if(x &lt; y){20 t = y;21 y = x;22 x = t;23 }24 do{25 z = x % y;26 x = y;27 y = z;28 }while(z != 0);29 ans = x;30 printf(\"%d is the GCD\\n\",ans);31 scanf(\"%d\", &amp;a);32 if(a % 2 != 0){33 printf(\"%d is not an even number\\n\",a);34 }else{35 printf(\"%d is an even number\\n\",a);36 }37 scanf(\"%d %d\",&amp;x,&amp;y);38 if(x &lt; y){39 t = y;40 y = x;41 x = t;42 }43 do{44 z = x % y;45 x = y;46 y = z;47 }while(z != 0);48 ans = x;49 printf(\"%d is the GCD\\n\",ans);50 scanf(\"%d\", &amp;a);51 if(a % 2 != 0){52 printf(\"%d is not an even number\\n\",a);53 }else{54 printf(\"%d is an even number\\n\",a);55 }56 scanf(\"%d %d\",&amp;x,&amp;y);57 if(x &lt; y){58 t = y;59 y = x;60 x = t;61 }62 do{63 z = x % y;64 x = y;65 y = z;66 }while(z != 0);67 ans = x;68 printf(\"%d is the GCD\\n\",ans);69 return 0;70} 相信你已经感到不耐烦了，毕竟这题弱智得很。不过请深呼吸冷静下来。作为软件工程业者，我们以后见到的需求可能要比这弱智的多，要学会习惯。 在冷静下来之后，我们来看这段代码。这道题目神神叨叨说了那么一堆，实际上无非就是判断是否为偶数以及求最大公因数这两种功能的多次实现。目前而言，我们的实现方式只能是把它复制若干次。这样不仅效率低，而且会造成代码的无意义重复，造成工程文件冗余。此外，随着代码长度的增加，可读性直线下降。当这种情况出现的时候，我们就可以说，这个程序代码复用率太低。 综上所述，我们在做题时遇到了代码可读性不佳以及代码复用率太低的问题。既然已经发现了问题，我们就想办法去分析问题出现的原因，进而解决他们。 我们看到，在我们解决题目1和题目2的时候，并没有出现很严重的缺憾。真正的问题出现在了题目3和题目4。这就是说，这两道题目会使问题暴露出来。而又是什么导致了问题的暴露呢？ 答案很简单。例1.1和例1.2都是简单单一功能的程序。而题目3和题目4则是多个不同单一功能程序块的复合。这种共性给了我们某种启发。即单个程序块能实现的功能越简单越好。而将多个单一功能程序块进行组合，形成的程序可能存在诸多隐患。而这种隐患在没有将程序块进行合适的处理的情况下尤为明显。简单粗暴组合而成的程序颇似一个缝合怪或是要你命三千，表面上看起来的确解决了问题，但是实际运用起来的效果可想而知。 上文我们谈到了对程序块进行合适的处理。而这个合适的处理，就是本节要讲的——函数。 函数初步​ 我们在中学学过函数，大家都知道“凡式中含天,为天之函数”，数学上的函数是描述不同变量之间的关系的一种定义。而在计算机领域所说的函数与数学领域所说的函数其实有所区别。函数的英文为function，我们知道，function有多种意思，其中最主要也是最常用的含义并不是数学意义上的“函数”，而是“作用、功能、职能”。而这三个释义才更为接近计算机领域中的“函数”一词。实际上，在计算机领域，函数就是指一段在一起的、可以做某一件事儿的程序。也叫做子程序或者方法。 ​ 从函数的定义我们可以看出，函数是“做某一件事”的。而我们的题目1和题目2所编写的程序，也是只能“做某一件事”的。下面我将例1.1和例1.2改写为函数，你可以对比一下改写为函数形式与原程序的区别。以及函数他长什么样子 1//例2.12void isEven(){3 int a;4 scanf(\"%d\", &amp;a);5 if(a % 2 != 0){6 printf(\"%d is not an even number\",a);7 }else{8 printf(\"%d is an even number\",a);9 } 10} 1//例2.22void GCD(){3 int x,y,z,t,ans;4 scanf(\"%d %d\",&amp;x,&amp;y);5 if(x &lt; y){6 t = y;7 y = x;8 x = t;9 }10 do{11 z = x % y;12 x = y;13 y = z;14 }while(z != 0);15 ans = x;16 printf(\"%d is the GCD\",ans); 17} 一个最基本的函数应该包括以下结构 1return_type function_name( parameter list )2{3 body of the function4} 其中，return_type为返回值类型，function_name为函数名，parameter为参数表，大括号中间为函数体。 例如，拿例2.1来说，void为返回类型，isEven为该函数名，该函数无参数，故参数表留空，大括号内就是我们之前写的实现判断奇偶性的函数正文。 你可能会发现函数的结构相当眼熟，还记得我们的第一个C语言程序么 1#include&lt;stdio.h&gt;2int main(){3 printf(\"Hello world!\");4} 实际上，这个main就是一个函数，被称为main函数，是每一个C语言程序中最重要的部分。 你可能见过很多main函数的写法，诸如int main(void)/void main()甚至int main(argc, char** argv)。不过我们只写int main()就行。 一下子接触很多新概念可能让人有点头疼，不过现在不用担心什么返回类型或是什么参数表的问题，我们会在接下来一一解决。 现在我们将例1.1和1.2改写为了函数形式的例2.1和2.2，不过，我们已经知道一个完整的C语言程序必须要在那个main函数内写点什么，现在我们只写了函数，main函数里面还是空的，这样肯定无法运行。我们需要让main函数安排上他要做的任务。或者用更专业的话来讲，在main函数内调用其他函数。 调用函数的方式很简单，请看例2.1.1 1//例2.1.12#include&lt;stdio.h&gt;3void isEven(){4 int a;5 scanf(\"%d\", &amp;a);6 if(a % 2 != 0){7 printf(\"%d is not an even number\",a);8 }else{9 printf(\"%d is an even number\",a);10 } 11}12int main(){13 isEven();14 return 0;15} 当你想要在main函数内调用其他函数的时候，只要将函数名以及括号出来就行了。注意，括号务必不可省略。唯有加上括号，编译器才会认为这个叫isEven的东西是一个函数，它才会去寻找对应的函数体，进而运行相应的函数功能。 注意：函数可以嵌套调用，但不可以嵌套定义，即你不能够在函数内定义函数。 下面请你尝试着在主函数调用例2.2的函数，如果程序能够运行且预期结果正确，我们进入下一部分。如果出现了错误，不要惊慌，认真阅读错误提示信息（你能看得懂的），并使用搜索引擎获得帮助。 函数类型与返回值我们假设你已经成功的在主函数中调用了例2.2，现在你的程序应该像这样 1//例3.12#include&lt;stdio.h&gt;3void GCD(){4 int x,y,z,t,ans;5 scanf(\"%d %d\",&amp;x,&amp;y);6 if(x &lt; y){7 t = y;8 y = x;9 x = t;10 }11 do{12 z = x % y;13 x = y;14 y = z;15 }while(z != 0);16 ans = x;17 printf(\"%d is the GCD\",ans); 18}19int main(){20 GCD();//调用函数21 return 0;22} 现在运行这个程序，他就会满足我们的要求，将你输入的两个数字的最大公因数打印在控制台上。 但是，我们不能总是面向黑框框控制台编程，如果我想要在主函数内获得这个最大公因数以进行更复杂的操作，怎么办？直观地说，我们将函数比喻成一个小工厂，现在你已经知道这个工厂会生产出特定的产品，但是，如果你想要对这种产品进行进一步的深加工的话，就应该有某种方法将这个产品“传出来”，那么谁来做这个传送带呢？返回值便是这个传送带。 此时，还存在一个问题，传送带和被传送的物品必须匹配，你不能用管道运输家具，你也不能用传送带运天然气。体现在C语言这一强类型语言中，就存在数据类型的问题。 请看例3.2 1//例3.22#include&lt;stdio.h&gt;3int GCD(){4 int x,y,z,t,ans;5 scanf(\"%d %d\",&amp;x,&amp;y);6 if(x &lt; y){7 t = y;8 y = x;9 x = t;10 }11 do{12 z = x % y;13 x = y;14 y = z;15 }while(z != 0);16 ans = x;17 return ans;18}19int main(){20 int num;21 num = GCD();//将函数的返回值赋值给num22 printf(\"%d\\n\",num);23 return 0;24} 我们看到，例3.2中的函数GCD和例3.1中不一样了，void变为了整型int，同时新加了return ans语句。相信大家能够明白，这里的int就是函数类型，而整型变量ans则为返回值。不言而喻，函数类型与返回值的数据类型必须匹配。 那么这个返回值在主函数中如何体现呢？很简单，函数在主函数内就近似一个，我们只需用对变量进行一次赋值即可将函数的返回值传回主函数。例3.2中的num=GCD（）语句所进行的动作，就是运行一次GCD函数，然后将GCD函数的返回值赋给整型变量num。注意：主函数内承接返回值的变量类型应与函数类型相统一。这里的num是整型，函数GCD()的类型也为整型，因此才能够将GCD()的返回值传给num。 可以看出，函数类型是与数据类型相关联的，因此，C语言的大部分数据类型基本都可以作为函数类型。比较特别的是函数还有一种void类型，该型函数无返回值，不需要写return语句。我们的例2.1和例2.2就是这种情况。 此外，一个函数是可以有多个return语句的，常见于函数内存在选择结构的情况，不过我们一般不建议编写这种多出口函数。 参数表与参数传递现在，我们的函数GCD()已经有了自己的返回值，可以将结果传出做进一步处理了。但是这样仍然不够，在日常开发中，我们希望函数专注于数据与逻辑层面，尽量减少函数与用户的直接人机交互。人机交互更多的交由main函数或是专门的函数去处理，以实现函数的进一步封装。体现在例题中，就是我们要把scanf语句从函数GCD()中拿出去，拿到main函数里面去。 问题出现了：我们怎样让函数GCD()知道它要求的是哪两个数的最大公因数呢？类比返回值的“传出”功能。我们现在需要的是一种“传入”功能。在C语言中，这种功能由函数的参数表实现。 我们看例4.1 1//例4.12#include&lt;stdio.h&gt;3int GCD(int x,int y){4 int z,t,ans;5 if(x &lt; y){6 t = y;7 y = x;8 x = t;9 }10 do{11 z = x % y;12 x = y;13 y = z;14 }while(z != 0);15 ans = x;16 return ans;17}18int main(){19 int num;20 int a,b;21 scanf(\"%d %d\",&amp;a,&amp;b);22 num = GCD(a, b);//传入参数23 printf(\"%d\\n\",num);24 return 0;25} 现在，函数后面那个括号内有了东西。我们知道括号内为该函数的参数表，现在函数GCD()的参数即为整型变量x和y。一个函数可以有若干个不同类型的参数，参数之间用逗号隔开。 而在主函数内将参数传入函数，只需按照函数的参数表，将需要传入的参数变量名写入函数名后的括号即可。很直观。 这样看来，传参是很简单的。但事情往往没法这么简单的结束，我们再来看函数GCD()。实际上，函数GCD还包括着一个功能模块，在do语句前的部分进行了一次对变量x、y的大小判断，若x比y小，则交换二者的数值。这个功能模块与本函数的目标功能关系不是很大，毕竟我们编写函数GCD()的目的是求最大公因数，而不是交换两个数字。我们不妨将这个交换数字的部分抽出来，再写一个函数 1//例4.22#include&lt;stdio.h&gt;3void swap(int x,int y){4 int t;5 t = y;6 y = x;7 x = t;8}9int GCD(int x,int y){10 int z,ans;11 if(x &lt; y){12 swap(x,y);//在函数里调用另一个函数是可以的13 }14 do{15 z = x % y;16 x = y;17 y = z;18 }while(z != 0);19 ans = x;20 return ans;21}22int main(){23 int num;24 int a,b;25 scanf(\"%d %d\",&amp;a,&amp;b);26 num = GCD(x, y);27 printf(\"%d\\n\",num);28 return 0;29} 运行一下试试看，发现程序出错了。显然是我们的swap()函数出现了某种问题。你可以打开调试功能，看一看到底是哪一步出了问题。 问题很明确，我们编写swap函数的预期功能是交换它的两个参数的位置，而在函数结束后，主调函数（调用函数的函数）内的变量值并没有发生改变，这是怎么一回事？ 这个问题的出现，是由C语言的传值方式所决定的。 实际上，当参数类型为基本类型时，函数的默认传值方式为单向值传递； 下面以函数GCD()中调用函数swap()为例，讲一下函数传值的微观过程。 在函数GCD()运行到swap(x,y)语句时，由于该函数存在参数，进入参数传递流程。 编译器会按照函数的参数表，为函数的参数分配内存单元 编译器将函数调用时实际传入的值赋给刚才为函数参数分配的内存单元 通常我们将函数的参数表成为函数的形式参数，而函数被调用时传入的值称为实际参数。 传参就是一个形实结合的过程，通过参数传递的流程，我们可以看出基本类型的函数传值有以下特点 单向：参数的传递仅由实际参数传给形式参数，形式参数无法对实际参数造成影响。换句话说，当传参结束后，被调用的函数体内的一切变化，无法影响到该函数的主调函数（调用该函数的函数）内的任何变量。 值传递：传参实际上是编译器将实际参数的值复制一份给形式参数的过程，在此过程中只有值发生了传递。 综上所述，这就是所谓的单向值传递。 那么我们是不是就永远没法写出称心如意的swap()函数了呢？方法总比困难多，不过要等你学完指针后，这个问题才能够解决。这里我们不多讨论。 实际上，只要记住一点就行。 当参数类型不为引用或指针时，函数内对参数做出的任何操作均只能停留在函数内，无法影响到主调函数。 参数传递这样看起来有些迷惑，不过当你实际入手编写几个程序试试，并打开调试功能查看了程序运行到不同语句时变量的变化情况时，这可能就不那么难理解了。 函数原型我们先抛开让人一头雾水的参数传递，回到之前的几个题目。 在我们学习了函数的基本知识后，现在我们应该可以把例1.4简化为下面的程序 1#include&lt;stdio.h&gt;2void isEven(int a){3 if(a % 2 != 0){4 printf(\"%d is not an even number\\n\",a);5 }else{6 printf(\"%d is an even number\\n\",a);7 } 8}9int GCD(int x,int y){10 int z,t,ans;11 if(x &lt; y){12 t = y;13 y = x;14 x = t;15 }16 do{17 z = x % y;18 x = y;19 y = z;20 }while(z != 0);21 ans = x;22 return ans;23}24int main(){25 int a;26 int x,y;27 scanf(\"%d\", &amp;a);28 isEven(a);29 scanf(\"%d\", &amp;a);30 isEven(a);31 scanf(\"%d %d\",&amp;x,&amp;y);32 printf(\"%d is the GCD\\n\",GCD(x,y));33 scanf(\"%d\", &amp;a);34 isEven(a);35 scanf(\"%d %d\",&amp;x,&amp;y);36 printf(\"%d is the GCD\\n\",GCD(x,y));37 return 0;38} 比起1.4，现在是不是好多了。 通过使用函数，我们极大地提升了主函数现在的可读性。但是我们还不满足于此。现在我们只有两个函数。但是如果我们编写了一个很复杂的程序，可能有五个、十个甚至更多函数，这时候就出现了一个问题。在主函数之前，可能有上千行代码。而这是不符合人类阅读习惯的，我们习惯把最重要的东西放在最前面，因此，我们需要把main函数放在最前面，这样，阅读代码时，我们就可以自主函数内按图索骥，等到函数被用到时，再去阅读它，由宏观至微观，提升可读性。 如何做到这一点呢？ 朴素的想法当然是把函数拿到后面去 1#include&lt;stdio.h&gt;2int main(){3 int a;4 int x,y;5 scanf(\"%d\", &amp;a);6 isEven(a);7 scanf(\"%d\", &amp;a);8 isEven(a);9 scanf(\"%d %d\",&amp;x,&amp;y);10 printf(\"%d is the GCD\\n\",GCD(x,y));11 scanf(\"%d\", &amp;a);12 isEven(a);13 scanf(\"%d %d\",&amp;x,&amp;y);14 printf(\"%d is the GCD\\n\",GCD(x,y));15 return 0;16}17void isEven(int a){18 if(a % 2 != 0){19 printf(\"%d is not an even number\\n\",a);20 }else{21 printf(\"%d is an even number\\n\",a);22 } 23}24int GCD(int x,int y){25 int z,t,ans;26 if(x &lt; y){27 t = y;28 y = x;29 x = t;30 }31 do{32 z = x % y;33 x = y;34 y = z;35 }while(z != 0);36 ans = x;37 return ans;38} 运行，然后就报错了。 为什么呢？ 我们的编译器在编译程序时是按照文件逐行编译的，当我们交换了函数的次序后，主函数就会比普通函数先编译，而在编译过程中，编译器顶不住了。他不知道这个唐突出现的isEven和GCD是些啥东西，编译器觉得我在这之前没有看到你对isEven和GCD的定义，所以这里肯定是出错了，于是你的程序就报错了。 如何解决呢？ 很简单，既然编译器不知道这两个名字是什么东西，我们就让它知道一下。 1#include&lt;stdio.h&gt;23void isEven(int a);4int GCD(int x,int y);56int main(){7 int a;8 int x,y;9 scanf(\"%d\", &amp;a);10 isEven(a);11 scanf(\"%d\", &amp;a);12 isEven(a);13 scanf(\"%d %d\",&amp;x,&amp;y);14 printf(\"%d is the GCD\\n\",GCD(x,y));15 scanf(\"%d\", &amp;a);16 isEven(a);17 scanf(\"%d %d\",&amp;x,&amp;y);18 printf(\"%d is the GCD\\n\",GCD(x,y));19 return 0;20}21void isEven(int a){22 if(a % 2 != 0){23 printf(\"%d is not an even number\\n\",a);24 }else{25 printf(\"%d is an even number\\n\",a);26 } 27}28int GCD(int x,int y){29 int z,t,ans;30 if(x &lt; y){31 t = y;32 y = x;33 x = t;34 }35 do{36 z = x % y;37 x = y;38 y = z;39 }while(z != 0);40 ans = x;41 return ans;42} 可以看到，我们在main函数前面加了两行语句。该语句成为函数的原型（或函数的声明）。它的作用就是首先告诉编译器：我这个程序里会有叫isEven和GCD的两个函数，他们的参数表是这个样子的。 然后编译器在编译到主函数时就知道唐突出现的这两个名字是什么东西了，因此，编译过程就可以继续进行。 实际上，函数的原型只需要提供参数类型即可，参数名不是必要的。 上例中的两个原型也可写为 1void isEven(int);2int GCD(int,int); 编译器需要的只是这个函数需要分配的内存单元大小。 全局变量、作用域与静态函数所谓作用域，就是变量的有效范围，就是变量可以在哪个范围以内使用。有些变量可以在所有代码文件中使用，有些变量只能在当前的文件中使用，有些变量只能在函数内部使用， 有些变量只能在 for 循环内部使用。 变量的作用域由变量的定义位置决定，在不同位置定义的变量，它的作用域是不一样的。 在我们之前编写程序的时候，我们都将变量定义在函数体内，如果我们拿出来的话会怎么样呢？ 1#include&lt;stdio.h&gt;2int i = 1;3void foo(){4 printf(\"foo i = %d\\n\",i);5}6int main(){7 printf(\"main i = %d\\n\",i);8 foo();9 return 0;10} 运行程序，我们会发现，函数foo()和主函数中打印出的i是同一个数字。 自此，我们引入全局变量的定义： 在所有函数外部定义的变量称为全局变量，它的作用域默认是整个程序，也就是所有的源文件，包括 .c 和 .h 文件。 相应的，在函数内部定义的变量，它的作用域也仅限于函数内部，出了函数就不能使用了，我们将这样的变量称为局部变量 如果我们在函数foo内定义了同名变量，会发生什么呢 1#include&lt;stdio.h&gt;2int i = 1;3void foo(){4 int i = 2;5 printf(\"foo i = %d\\n\",i);6}7int main(){8 foo();9 printf(\"main i = %d\\n\",i);10 return 0;11} 运行程序，可以看出，我们在函数内定义的同名变量覆盖了全局变量。 此外，在函数内也可以修改全局变量，这种修改的结果是全局有效的，在函数foo内对i的值进行修改则主函数内i的值也会发生变化，你可以自己尝试一下。 C语言规定，在同一个作用域中不能出现两个名字相同的变量，否则会产生命名冲突；但是在不同的作用域中，允许出现名字相同的变量，它们的作用范围不同，彼此之间不会产生冲突。这句话有两层含义： 不同函数内部可以出现同名的变量，不同函数是不同的局部作用域； 函数内部和外部可以出现同名的变量，函数内部是局部作用域，函数外部是全局作用域。 不同函数内部的同名变量是两个完全独立的变量，它们之间没有任何关联，也不会相互影响。 函数内部的局部变量和函数外部的全局变量同名时，在当前函数这个局部作用域中，全局变量会被“屏蔽”，不再起作用。 讨论完了定义域，我们再来看一种不同的函数形式。如果现在我们想要知道一个函数在整个程序运行的过程中一共被调用了几次，该怎么办？ 联想到静态变量，我们可以运用静态函数完成这点 1#include&lt;stdio.h&gt;2static int foo(){3 int i;4 i++;5 return i;6}7int main(){8 foo();9 foo();10 foo();11 printf(\"%d\",foo());12} 运行程序，输出结果4，而foo函数确实被调用了四次。可以看到，静态函数具有和静态变量相似的性质。 静态函数具有以下特性： 用static修饰的函数，被限定在本源码文件中，不能被本源码文件以外的代码文件调用。 其他文件中可以定义相同名字的函数，不会发生冲突。 后记现在，你应该对C语言中的函数有了一个大致的了解。简单来说，函数的用处就是我们在引入里面所提到的提高代码复用率和增强代码可读性。函数无非就是功能细分后的小程序，每一个程序都可以看做是由若干函数所组合而成的。此外，函数在面向对象编程方法中，也是至关重要的一个点。在学完函数后，便可以说是C语言学习基本开始入门了。希望你到目前为止，能够形成对程序设计的一个基本价值观和方法论。当然，作为一个工科学科，实践仍是最重要的，纸上得来终觉浅。究竟何种类型的功能模块应该被封装为函数？函数之间如何沟通才能进一步提升程序的可读性和运行效率？这些都是要从实践中来的经验。 ​ WEB部 Aldrich","link":"/C%E6%95%99%E7%A8%8B%E6%95%99%E7%A8%8B-%E5%87%BD%E6%95%B0%E9%83%A8%E5%88%86.html"}],"tags":[{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"}],"categories":[{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}