{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/12/05/hello-world/"},{"title":"图的邻接矩阵存储、最小生成树普里姆算法以及最短路径的Dijkstra算法","text":"图的邻接矩阵存储及其实现邻接矩阵是常用的存储图的信息的方法，如下图所示 其中，边数组描述了图上的各个顶点之间的关系。此矩阵通常具有以下性质 对角线上的元素全部为0，表示每个顶点到自身的权值/距离为0 若图为无向图，则邻接矩阵为对称矩阵 其余元素表示各顶点之间的路径权值，若为无限或其他规定值，则顶点与顶点之间不联通 由此可以看出，我们若想在程序中采用邻接矩阵的方式对图进行存储，需要建立一个用来存储顶点信息的一维数组和一个用来存储边信息的二位数组。 以下为图的邻接矩阵存储的C语言类型定义实现 1typedef struct {2 vertextype vex[M]; //顶点信息3 edgetype edges[M][M];//邻接矩阵4 int n; //顶点数5 int e; //边数6}Mgraph; 方便起见，我们从文件中对图的数据进行读入，文件格式如下 16 102ABCDEF30 1 1040 2 1250 4 1561 2 772 4 1281 3 591 5 6102 5 8113 5 6124 5 10 其中，第一行的两个数字分别表示该图中顶点的个数以及边的个数。第二行的字母表示每个顶点的名称。 其余各行则以“起始点 结束点 权值”的格式描述了图的结构。如在以上文件中，“0 1 10”表示从第0个点到第1个点有一条权值10的边。 图的邻接矩阵存储算法如下 1#include &lt;stdio.h&gt;2#define FINITY 50003#define M 20 //最大顶点数4typedef char vertextype; //顶点值类型5typedef int edgetype; //权值类型6void create(Mgraph *g,char *s,int c){ //C=0表示建立无向图，否则建立有向图7 int i,j,k,w;8 FILE *rf;9 rf = fopen(s,\"r\");10 if(rf){11 fscanf(rf,\"%d%d\",&amp;g-&gt;n,&amp;g-&gt;e); //输入顶点数与边数12 for(i = 0;i&lt;g-&gt;n;i++){13 fscanf(rf,\"%1s\",&amp;g-&gt;vex[i]); //输入顶点名14 }15 for(i = 0;i&lt;g-&gt;n;i++){ //初始化邻接矩阵16 for(j = 0;j&lt;g-&gt;n;j++){17 if(i==j){18 g-&gt;edges[i][j] =0; //邻接矩阵对角线置019 }else{20 g-&gt;edges[i][j] = FINITY;//其余置无限21 }22 }23 }24 for(k = 0;k&lt;g-&gt;e;k++){25 fscanf(rf,\"%d%d%d\",&amp;i,&amp;j,&amp;w); //读入文件中的顶点i，顶点j，权值w26 g-&gt;edges[i][j] = w; //邻接矩阵i行j列信息置权值27 if(c==0){28 g-&gt;edges[j][i]=w; //若为无向图，则j行i列信息也置权值29 }30 }31 fclose(rf);32 }else{33 g-&gt;n=0;34 }35} 以上，我们实现了图的邻接矩阵存储 图的最小生成树的普里姆算法 一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。 最小生成树可以用kruskal（克鲁斯卡尔）算法或prim（普里姆）算法求出。 简单来说，就是在把图的各个顶点连接起来的同时，保证路径的总权值最小。 下面介绍图的普里姆算法 此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。 图的所有顶点集合为V；初始令集合u={s},v=V−u; 在两个集合u,v能够组成的边中，选择一条权重最小的边(u0,v0)，加入到最小生成树中，并把v0并入到集合u中。 重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。 由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组tree[],用来维护集合v中每个顶点与集合u中最小代价边信息，： 以下为其算法实现 1//边集2typedef struct {3 int beg; //起始顶点4 int en; //结束顶点5 int length; //权值6}edge;78//普里姆算法9void prim(Mgraph g,edge tree[M-1]){10 edge x;11 int d,min,j,k,s,v;12 for(v = 1;v&lt;=g.n-1;v++){ //初始化边集tree中的每一个元素i为起点为0，终点为v的边13 tree[v-1].beg = 0;14 tree[v-1].en = v;15 tree[v-1].length = g.edges[0][v];16 }17 for(k = 0;k&lt;=g.n-3;k++){18 min = tree[k].length; //初始化程序当前认为的最小边min19 s = k;20 for(j = k+1;j&lt;=g.n-2;j++){21 if(tree[j].length&lt;min){ //如果当前边的权值小于目前最小值22 min = tree[j].length; //令最小值等于当前边权值23 s = j; //令s等于最短边在tree中的索引24 }25 }26 v = tree[s].en; //取最短边的结束点为v27 x = tree[s]; //交换tree中的第s条边和第k条边，使当前最小边加入tree28 tree[s] = tree[k]; 29 tree[k] = x; //交换完毕后，此时tree数组中的前k个元素为已经求得的最短路径30 for(j=k+1;j&lt;=g.n-2;j++){ //由于v更换，更新两栖边信息，注意此处由k+1开始遍历tree31 d = g.edges[v][tree[j].en]; 32 if(d&lt;tree[j].length){33 tree[j].beg = v; //设定tree[j]的起始点为v34 tree[j].length = d; //更新当前结束点v到tree[j]元素的距离35 }36 }37 }38 //输出最小生成树39 printf(\"\\n the minimun cost spanning tree is :\\n\");40 for(j = 0;j&lt;=g.n-2;j++){41 printf(\"\\n%c---%c %d\\n\",g.vex[tree[j].beg],g.vex[tree[j].en],tree[j].length);42 }43 printf(\"\\n the root of it is %c\\n\",g.vex[0]);44} 运行结果如下 1# 测试数据 G1.txt26 103ABCDEF40 1 1050 2 1260 4 1571 2 782 4 1291 3 5101 5 6112 5 8123 5 6134 5 10 1#终端输出2the minimun cost spanning tree is :3A---B 104B---D 55B---F 66B---C 77F---E 10 由此，我们利用了普里姆算法求得了图的最小生成树。 利用Dijkstra算法求图的单源最短路径求解图的单源最短路径问题很好理解，就是对于给定的图上的顶点v0，找出一条路径使其能够到达其他顶点且路径的权重和最小。 我们可以利用Dijkstra算法求解图的单源最短路径； 基本思想：每次找到离源点（如1号结点）最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。 以下为其算法实现 1typedef enum {FALSE,TRUE} boolean; //令FALSE为0，TRUE为12typedef int dist[M]; //用于保存边的信息3typedef int path[M]; //用于保存路径信息45void dijkstra(Mgraph g,int v0,path p,dist d){6 boolean final[M]; //初始化final数组用于标记当前元素是否已求出最短路径7 int i,j,k,v,min,x;8 for(v = 0;v&lt;g.n;v++){ //初始化第一组集合9 final[v] = FALSE; //当前元素未求出最短路径10 d[v] = g.edges[v0][v]; //令d[v]等于v0至v的距离11 if(d[v]&lt;FINITY &amp;&amp; d[v]!=0){ //若v0至v的距离不为无限或012 p[v] = v0; //则令p的前驱为v013 }else{14 p[v] = -1; //否则，p无前驱15 }16 }17 final[v0] = TRUE; //初始化源点18 d[v0] = 0; 19 for(i = 1;i&lt;g.n;i++){20 min = FINITY; //初始化最小值21 for(k = 0;k&lt;g.n;k++){ //遍历图找寻最短路径，g.n表示图的顶点数22 if(!final[k] &amp;&amp; d[k]&lt;min){ //若k未被访问过且k的权值小于当前最小值23 v = k; //标记索引为k的顶点为v24 min = d[k]; //当前最小值置k的权值25 }26 }27 printf(\"\\n%c---%d\\n\",g.vex[v],min);28 if(min == FINITY){ //非连通图不存在生成树，返回29 return;30 }31 final[v] =TRUE; //v与源点之间存在最短路径32 for(k = 0;k&lt;g.n;k++){ //源点改变为v，更新路径信息33 if(!final[k] &amp;&amp; (min+g.edges[v][k]&lt;d[k])){ //若k未访问过且当前路径长度小于v0至k的权值34 d[k] = min+g.edges[v][k]; //路径长度相加35 p[k] = v;36 }37 }38 }39}40//输出最短路径41void print_gpd(Mgraph g,path p,dist d){42 int st[M],i,pre,top = -1;43 for(i = 0;i&lt;g.n;i++){44 printf(\"\\n Distancd :%7d path:\",d[i]);45 st[++top] = i;46 pre = p[i];47 while(pre !=-1){48 st[++top] = pre;49 pre = p[pre];50 }51 while(top&gt;0){52 printf(\"%2d\",st[top--]);53 }54 }55}","link":"/2019/12/05/prim-dijkstra/"}],"tags":[{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}